import { LineEdit } from "std-widgets.slint";
import { ItemInfo } from "item_info.slint";



export enum Category { Work, Utility, Entertainment, Travel, Food, Subscriptions }

export global CategoryProps {
    in-out property <Category> global_category;
    in-out property <bool> change_complete: false;
}

export component ItemContainer inherits Rectangle {

    // Size of scroll view container.
    width: 410px;

    in-out property <int> item_index;

    in-out property <string> item_name <=> iname.text;
    in-out property <string> item_cost <=> icost.text;
    in-out property <Category> item_category ;
    // <=> icategory.category;

    in-out property <bool> changing_category: false;

    callback change_category();


    // Main Rectangle
    Rectangle {
        height: 65px;

        category_edit:= Rectangle {
            width: 30px;
            height: 30px;
            x: 20px;
            y: 0;
            z: 1;
            border-radius: 15px;
            border-color: {
                item_category == Category.Entertainment ?
                yellow : item_category == Category.Food ? 
                green : item_category == Category.Subscriptions ?
                purple : item_category == Category.Travel ?
                lightblue : item_category == Category.Utility ?
                red : blue // blue is for "Work" category!
            };
            border-width: 1px;

            Image {
                width: 25px;
                height: 25px;
                source: @image-url("../../logos/category logo.svg");

                TouchArea {
                    clicked => {
                        change_category();
                        changing_category = true;
                    }
                }
            }
        }

        // Category Rectangle
        icategory:= Rectangle {
            x: 0;
            height: 50px;
            width: 410px;
            in-out property <Category> category: item_category;  //pre-defined/stored value

            background: {
                if (self.category == Category.Food) {
                    return green;
                }
                if(category == Category.Entertainment) {
                    return yellow;
                }
                if (self.category == Category.Subscriptions) {
                    return purple;
                }
                if (category == Category.Utility) {
                    return red;
                }
                if (category == Category.Work) {
                    return blue;
                }
                if (category == Category.Travel) {
                    return lightblue;
                }
                return gray;
            }


            iname := ItemInfo {
                height: parent.height;
                info_x: 0px;
            }
           
            icost := ItemInfo{
                height: parent.height;
                info_x: 200px;
            }

            
        }

        editInfo:= Rectangle{
            x: 360px;
            width: 30px;
            height: 30px;
            y: 0;
            z: 1;
            in-out property <bool> beingEdited;

            border-color: {
                beingEdited ? 
                black : 
                white
            };
            
            border-radius: 15px;
            border-width: 1px;
            Image {
                width: 20px;
                height: 20px;

                source: beingEdited ?
                    @image-url("../../logos/pencil logo.svg")
                    : @image-url("../../logos/correct logo.svg");

                colorize: {
                    beingEdited ?
                    black :
                    white
                };

                TouchArea {
                    clicked => {

                        // If the text is indeed being updated, then reverse this.
                        if (editInfo.beingEdited) {
                            editInfo.beingEdited = false;

                            iname.beingEdited = false;
                            iname.read-only = true;

                            icost.beingEdited = false;
                            icost.read-only = true;
                            
                            return;
                        }

                        // If text is NOT being updated, then reverse this.
                        if (!editInfo.beingEdited) {
                            editInfo.beingEdited = true;

                            iname.beingEdited = true;
                            iname.read-only = false;

                            icost.beingEdited = true;
                            icost.read-only = false;

                            return;
                        }
                    }
                }
            }
        }

    }
}
